/*!

\page tutorial Tutorial

This short tutorial covers the basic steps and building blocks needed for implementing your own scope with unity-scopes-api, using C++. For complete examples of various scopes see demo/scopes subdirectory of the unity-scopes-api source project.

\section simplescope A simple scope which doesn't query other scopes.

This is the typical case: a scope that connects to a remote or local backend, database etc. and provides results in response to search queries coming from a
client (i.e. Unity Dash or another scope).

\subsection scopebase Create a scope class that implements ScopeBase inteface.

There are a few pure virtual methods that need to be implemented; at the very minimum you need to provide a non-empty implementation of
\link unity::scopes::ScopeBase::start() start\endlink and unity::scopes::ScopeBase::search()  and
unity::scopes::ScopeBase::preview() methods. 

\code{.cpp}
class MyScope: public unity::scopes::ScopeBase
{
public:
    virtual int start(std::string const&, unity::scopes::RegistryProxy const&) override;
    virtual void stop() override;
    virtual void run() override;
    virtual unity::scopes::SearchQueryBase::UPtr search(CannedQuery const& query, SearchMetadata const& metadata) override;
    virtual unity::scopes::PreviewQueryBase::UPtr preview(unity::scopes::Result const& result, unity::scopes::ActionMetadata const& metadata) override;
}
\endcode

The \link unity::scopes::ScopeBase::start() start\endlink method must, at the very least return unity::scopes::ScopeBase::VERSION, e.g.

\code{.cpp}
int MyScope::start(string const&, unity::scopes::RegistryProxy const&)
{
    return ScopeBase::VERSION;
}
\endcode

The \link unity::scopes::ScopeBase::stop() stop\endlink method should release any resources, such as network connections where applicable. See the
documentation of \link unity::scopes::ScopeBase ScopeBase\endlink for an explanation of when \link unity::scopes::ScopeBase::run() ScopeBase::run\endlink;
is useful; for typical and simple cases the implementation of run can be an empty function.

\subsection handlingsearch Handling search

The unity::scopes::ScopeBase::search() method of scope implementation is the entry point of every search - it receives
search queries from the Dash or other scopes. This method must return an instance of an object that implements
unity::scopes::SearchQueryBase interface, e.g:

\code{.cpp}
SearchQueryBase::UPtr MyScope::search(CannedQuery const& query, SearchMetadata const& metadata)
{
    SearchQueryBase::UPtr q(new MyQuery(query));
    return q;
}
\endcode

\subsubsection querybase Create a query class that implements SearchQueryBase interface.

The central and most important method that needs to be implemented in this interface is unity::scopes::SearchQueryBase::run().
This is where actual processing of current search query takes place, and this is the spot where you may want to query local or remote data source for results
matching the query.

The unity::scopes::SearchQueryBase::run() method gets passed an instance of SearchReplyProxy, which represents a receiver of query results. Please note
that SearchReplyProxy is just a shared pointer for \link unity::scopes::SearchReply SearchReply\endlink object. The two most important
methods of SearchReply object that every scope have to use are \link unity::scopes::SearchReply::register_category register_category\endlink
and \link unity::scopes::SearchReply::push push\endlink.

The \link unity::scopes::SearchReply::register_category register_category\endlink method is a factory method for creating new categories (see
\link unity::scopes::Category\endlink). Categories can be created at any point during query processing inside run method, but it's recommended to create
them as soon as possible (ideally as soon as they are known to the scope).

When creating a category, one of its parameters is a \link unity::scopes::CategoryRenderer \endlink instance,
which specifies how will a particular category be rendered. See the unity::scopes::CategoryRenderer documentation for more on that subject.

The actual search results have to be wrapped inside \link unity::scopes::CategorisedResult CategorisedResult\endlink objects and
passed to \link unity::scopes::SearchReply::push push\endlink.

A typical implementation of run may look like this:

\code{.cpp}
void MyQuery::run(SearchReplyProxy const& reply)
{
    auto category = reply->register_category("recommended", "Recommended", icon);
    //... query a local or remote backend

    for (auto res: backend.get_results(search_query)) // for every result returned by a backend
    {
        ...
        CategorisedResult result(category); // create a result item in "recommended" category
        result.set_uri(...);
        result.set_title(...);
        result.set_art(...);
        result.set_dnd_uri(...);
        result["my-custom-attribute"] = Variant(...); // add arbitrary data as needed

        if (!reply->push(result)) // send result to the client
        {
            break; // false from push() means search was cancelled
        }
    }
}
\endcode

\subsection handlingpreview Handling previews

Scopes are responsible for handling preview requests for results they created; this needs to be implemented by overriding unity::scopes::ScopeBase::preview()
method:

\code{.cpp}
class MyScope: public unity::scopes::ScopeBase
{
public:
    ...
    virtual unity::scopes::PreviewQueryBase::UPtr preview(unitu::scopes::Result const& result, unity::scopes::ActionMetadata const& metadata) override;
    ...
}
\endcode

This method must return an instance derived from unity::scopes::PreviewQueryBase. The implementation of unity::scopes::PreviewQueryBase interface is similar to
unity::scopes::SearchQueryBase in that its central method is unity::scopes::PreviewQueryBase::run(). This method is responsible for gathering preview data (from
local or remote sources) and passing it along with the definition of preview look to unity::scopes::PreviewReplyProxy (this is a pointer to
unity::scopes::PreviewReplyBasel; the run() method receives a pointer to an instance of unity::scopes::PreviewReply).

A preview consists of one or more preview widgets - these are the basic building blocks for previews, such as a header with a title and subtitle, an image, a
gallery with multiple images, a list of audio tracks etc.; see unity::scopes::PreviewWidget for a detailed documentation and a list of supported widget types.
So, the implementation of unity::scopes::PreviewQueryBase::run() needs to create and populate one or more instances of unity::scopes::PreviewWidget and push them to the
client with unity::scopes::PreviewReply::push().

Every unity::scopes::PreviewWidget has a unique identifier, a type name and a set of attributes determined by its type. For example, a widget of "image" type expects
two attributes: "source", which should point to an image (an uri) and "zoomable" boolean flag, which determines if the image should be zoomable. Values of such
attributes can either be specified directly, or they can reference values present already in the unity::scopes::Result instance, or pushed spearately during the
execution of unity::scopes::PreviewQueryBase::run().

Attributes can be specified directly with unity::scopes::PreviewWidget::add_attribute() method, e.g:

\code{.cpp}
    PreviewWidget image_widget("myimage", "image");

    image_widget.add_attribute("source", Variant("file:///tmp/image.jpg"));
    image_widget.add_attribute("zoomable", Variant(false));
\endcode

To reference values from results or arbitrary values pushed separately, use unity::scopes::PreviewWidget::add_component() method:

\code{.cpp}
    PreviewWidget image_widget("myimage", "image");
    image_widget.add_component("source", "art"); // use 'art' attribute from the result
    image_widget.add_component("zoomable", "myzoomable"); // 'myzoomable' not specified, but pushed below
    reply->push("myzoomable", Variant(true));
\endcode

To push preview widgets to the client, use unity::scopes::PreviewReply::push():

\code{.cpp}
    PreviewWidget image_widget("myimage", "image");
    PreviewWidget header_widget("myheader", "header");
    // fill in widget attributes
    ...
    PreviewWidgetList widgets { image_widget, header_widget };
    reply->push(widgets);
\endcode

\subsubsection previewactions Preview actions

Previews can have actions (i.e. buttons) that user can activate - they are supported by unity::scopes::PreviewWidget of "actions" type. This type of widget
takes one or more action button definitions, where every button is constituted by an unique identifier, a label and an optional icon. For example, a widget with
two buttons: "Open" and "Download" can be defined as follows (using unity::scopes::VariantBuilder helper class):

\code{.cpp}
    PreviewWidget buttons("mybuttons", "actions");

    VariantBuilder builder;
    builder.add_tuple({
        {"id", Variant("open")},
        {"label", Variant("Open")}
    });
    builder.add_tuple({
        {"id", Variant("download")},
        {"label", Variant("Download")}
    });

    buttons.add_attribute("actions", builder.end());
\endcode

To handle activation of preview actions, scope needs to implement the following method of unity::scopes::ScopeBase:

\code{.cpp}
class MyScope: public unity::scopes::ScopeBase
{
    virtual ActivationQueryBase::UPtr perform_action(Result const& result, ActionMetadata const& metadata, std::string const& widget_id, std::string const& action_id) override
    ...
}
\endcode

This method receives a widget identifier and action identifier that was activated. 
This method needs to return an instance derived from unity::scopes::ActivationQueryBase. The derived class needs to reimplement
unity::scopes::ActivationQueryBase::activate() method and put any activation logic in there. This method needs to respond with an instance of
unity::scopes::ActivationResponse, which informs the shell about status of activation and the expected behaviour of the UI. For example, activate() may request
a new search query to be executed as follows:

\code{.cpp}
class MyActivation : public unity::scopes::ActivationQueryBase
{
    virtual unity::scopes::ActivationResponse activate() override
    {
        ...
        if (action_id == "search-grooveshark")
        {
            Query query("com.canonical.scopes.grooveshark");
            query.set_query_string("metal");
            return unity::scopes::ActivationResponse(query);
        }
        ...
    }
}
\endcode

\subsection handlingactivation Handling result activation

In most cases search results can be activated (i.e. when user taps or clicks them) directly by the shell - as long as a desktop schema used by that result's uri is
known to the shell. In some cases however scope may want to intercept and handle activation request. To do that, it has to reimplement
unity::scopes::ScopeBase::activate() method:

\code{.cpp}
class MyScope : public ScopeBase
{
    virtual ActivationQueryBase::UPtr activate(Result const& result, ActionMetadata const& metadata) override;
    ...
}
\endcode

and also call Result::set_intercept_activation() for all results that should trigger unity::scopes::ScopeBase::activate() on activation. The implementation of
unity::scopes::ScopeBase::activate() should follow the same guidelines as unity::scopes::ScopeBase::perform_action(), the only difference with result activation
being the lack of widget or action identifiers, as those are specific to preview widgets.

\subsection export Export the scope.

The scope needs to be compiled into a .so shared library and to be succesfully
loaded at runtime it must provide two C functions to create and destroy it - a
typical code snippet to do this looks as follows:

\code{.cpp}
extern "C" {
    EXPORT unity::scopes::ScopeBase* UNITY_SCOPE_CREATE_FUNCTION()
    {
        return new MyScope();
    }

    EXPORT void UNITY_SCOPE_DESTROY_FUNCTION(unity::scopes::ScopeBase* scope_base)
    {
        delete scope_base;
    }
}
\endcode

\section aggscope A simple aggregator scope which combines results from other scopes.

Aggregator scope is not much different from regular scopes, except for its data sources can include any other scope(s). The main difference is in the
implementation of run method of unity::scopes::SearchQueryBase and in the new class that has to implement
\link unity::scopes::SearchListenerBase SearchListenerBase\endlink interface, which receives result from other scope(s).

\subsection subquery Query another scopes via SearchQueryBase::subsearch()

To send search query to another scope, use one of the `subsearch()` overloads of unity::scopes::SearchQueryBase inside your implementation of unity::scopes::SearchQueryBase.
This method requires - among search query string - an instance of \link unity::scopes::ScopeProxy ScopeProxy\endlink that points to the target scope and an instance of class that implements
\link unity::scopes::SearchListenerBase SearchListenerBase\endlink interface. ScopeProxy can be obtained from unity::scopes::RegistryProxy and the right place to
do this is in the implementation of \link unity::scopes::ScopeBase::start() start()\endlink method of \link unity::scopes::ScopeBase ScopeBase\endlink interface.

\code{.cpp}

int MyScope::start(std::string const&, unity::scopes::RegistryProxy const& registry)
{
    try
    {
        scope_to_query_ = registry->find("scope-A"); // store the proxy for passing it further in search 
    }
    catch (NotFoundException const& e)
    {
        ...
    }
    return VERSION;
}

unity::scopes::QueryBase::UPtr MyScope::search(std::string const& query, unity::scopes::SearchMetadata const&)
{
    SearchQueryBase::UPtr q(new MyQuery(query, scope_to_query_));
    return q;
}

...

void MyQuery::run(unity::scopes::SearchReplyProxy const& upstream_reply) 
{
    auto category = reply->register_category("recommended", "Recommended", icon, "");
    SearchListenerBase::SPtr reply(new MyReceiver(upstream_reply, category));
    subsearch(scope_to_query_, query_, reply);
    ...
}
\endcode

\subsubsection receiver Create a class that implements SearchListenerBase interface

The \link unity::scopes::SearchListenerBase SearchListenerBase\endlink is an abstract class to receive the results of a query sent to a scope. Its virtual push methods let the
implementation receive \link unity::scopes::SearchListenerBase::push result items and categories\endlink returned by that query. A simple implementation of
an aggregator scope may just register all categories it receives and push all received results upstream to the query originator, e.g.

\code{.cpp}

void push(Category::SCPtr category)
{
    upstream_->register_category(category);
}

void MyReceiver::push(CategorisedResult result)
{
    upstream_->push(std::move(result));
}
\endcode

A more sophisticated aggregator scope can rearrange results it receives into a different set of categories, alter or enrich the results before pushing them
upstream etc.

\subsection aggactiv Activation and previews of results processed by aggregator scopes

If an aggregator scope just forwards results it receives from other scopes, possibly only changing their category assignment, then there is nothing
to do in terms of handling previews, preview actions and result activation: preview and perform_action requests will trigger respective methods of
unity::scopes::ScopeBase for the scope that created results. Result activation will trigger unity::scopes::ScopeBase::activate() method for the scope that
produced the result as long as it set interception flag for it. In other words, when aggreagor scope just forwards results (and makes only minor
adjustements to them, such as category assignment), it is not involved in preview or activation handling at all.

If, however, aggregator scope changes attributes of results (or creates completely new results that "replace" received results), then some extra care needs to
be taken:
<ul>
<li>if original scope should still handle preview (and activation) requests, then <b>aggregator has to store a copy of original result</b> in the modified (or brand
new) result. This can be done with unity::scopes::Result::store method. Preview request for such result will automatically trigger a scope that created the most
inner stored result, and that scope will receive the stored result. It will also do the same for activation as long as the original scope set interception flag
on that result.

\note Making substantial changes to received results and failing to store original results with them may result in unexpected behavior: a scope will
suddenly receive a modified version of it and depending on the level of changes, it may or may not be able to correctly handle it.

<li>if aggregator scope creates a completly new result that replaces original one, but doesn't store a copy of the original result, it is expected to handle
preview (and potentially activation requests - if interception activation flag is set) - this is no different than for normal scopes, see \ref handlingpreview and \ref handlingactivation .
</ul>

Consider the following example of implementation of unity::scopes::SearchListenerBase interface that modifies results and stores their copies, so that original
scope can handle previews and activation for them:

\code{.cpp}
void MyReceiver::push(CategorisedResult original_result)
{
    CategorisedResult result(agg_category); // agg_category is a category that aggregates all results from other scopes
    result.set_uri(original_result.uri());
    result.set_title(original_result.title() + "(aggregated)");
    result.set_art(original_result.art());
    result.store(original_result);

    upstream_->push(std::move(result));
}
\endcode

\section scopetesting Testing

Unity Scopes API provides testing helpers based on well-known and established testing frameworks:
<a href="https://code.google.com/p/googletest/">googletest</a> and <a href="https://code.google.com/p/googlemock/">googlemock</a>.
Please see respective documentation of those projects for general information about how to use Google C++ Testing Framework.

All the helper classes provided by Scopes API are located in unity::scopes::testing namespace. The most important ones are:
<ul>
<li>unity::scopes::testing::TypedScopeFixture - template class that takes your scope class name as a template argument and creates a test fixture that can be
used in tests.
<li>unity::scopes::testing::MockSearchReply - a mock of unity::scopes::SearchReply that makes it possible to intercept responses to search request sent from
the scope to a client, making it easy to test if your scope returns all expected data.
<li>unity::scopes::testing::MockPreviewReply - a mock of unity::scopes::PreviewReply that makes is possible to intercept and test responses to preview request
sent from the scope to a client.
<li>unity::scopes::testing::Result - a simple class defined on top of unity::scopes::Result that provides a default constructor, making it possible to create
dummy results (with no attributes) for testing purposes.
<li>unity::scopes::testing::category - a simple class defined on top of unity::scopes::Category that makes it possible to create dummy categories (which would
otherwise require an instance of unity::scopes::SearchReply and a call to unity::scopes::SearchReply::register_category()).
</ul>

With the above classes a test case that checks if MyScope calls appropriate methods of unity::scopes::SearchReply may look like this (note that it just checks
if proper methods get called and uses _ matchers that match any values; put actual values in there for stricts checks):
\code{.cpp}
typedef unity::scopes::testing::TypedScopeFixture<MyScope> TestScopeFixutre;
using namespace ::testing;

TEST_F(TestScopeFixutre, search_results)
{
    const unity::scopes::CategoryRenderer renderer;

    NiceMock<unity::scopes::testing::MockSearchReply> reply;
    EXPECT_CALL(reply, register_departments(_, _)).Times(1);
    EXPECT_CALL(reply, register_category(_, _, _, _))
            .Times(1)
            .WillOnce(
                Return(
                    unity::scopes::Category::SCPtr(new unity::scopes::testing::Category("id", "title", "icon", renderer))
                )
            );
    EXPECT_CALL(reply, register_annotation(_))
            .Times(1)
            .WillOnce(Return(true));
    EXPECT_CALL(reply, push(_))
            .Times(1)
            .WillOnce(Return(true));

    unity::scopes::SearchReplyProxy reply_proxy(&reply, [](unity::scopes::SearchReplyBase*) {}); // note: this is a std::shared_ptr with empty deleter

    unity::scopes::CannedQuery query(scope_id, "", "");
    unity::scopes::SearchMetadata meta_data("en_EN", "phone");

    auto search_query = scope->search(query, meta_data);
    ASSERT_NE(nullptr, search_query);
    search_query->run(reply_proxy);
}
\endcode
*/
